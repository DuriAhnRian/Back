# 1. Project Structure (프로젝트 구조)
```bash
src
└── main
    ├── java
    │   └── hello.durian.code
    │       ├── chat
    │       ├── evaluation
    │       ├── global
    │       │   ├── config
    │       │   ├── dto
    │       │   ├── entity
    │       │   ├── exception
    │       │   ├── interceptor
    │       │   ├── publisher
    │       │   ├── service
    │       ├── meeting
    │       ├── notification
    │       ├── place
    │       ├── sse
    │       ├── user
    │       │   ├── presentation
    │       │   ├── application
    │       │   ├── domain
    │       │   ├── infrastructure
    │       │   ├── dto
    │       └── DangdangcrewApplication
    ├── resources
    │   └── application.yml

```

<br/>
<br/>

# 2. Git Convention (깃 컨벤션)

## Label
| 태그 | 설명 |
|:------:|:------------------------------------------------|
| ⚙️ `build` | 빌드 관련 파일 수정 |
| ✅ `ci/cd` | CI/CD 설정 파일 수정 |
| ✍️ `comment` | 필요한 주석 추가 및 변경 |
| 📘 `docs` | 문서를 개선하거나 내용을 추가 |
| ✏️ `style` | 코드 포맷 변경, 세미콜론 누락 등 코드 변경 없음 |
| ✨ `feat` | 새로운 기능을 추가할 경우 |
| ❌ `remove` | 파일을 삭제하는 작업만 수행한 경우 |
| 🎨 `refactor` | 프로덕션 코드 리팩토링 |
| 💡 `rename` | 파일 혹은 폴더명을 수정하거나 이동한 경우 |
| 💡 `test` | 테스트 추가, 테스트 리팩토링 (프로덕션 코드 변경 X) |
| 🔨 `fix` | 버그를 고친 경우 |

<br/>

## ISSUE TEMPLATE
이슈명: 내용
<br/>

ex) 유저 CRUD 기능 추가
```
## 이슈
### 현재 상황
- 현재 발생한 문제나 개선이 필요한 상황을 설명해주세요.

### 목표
- 이슈를 통해 달성하고자 하는 목표를 설명해주세요.

## 작업 내용
- [ ] 작업 1
- [ ] 작업 2
- [ ] 작업 3

## 스크린샷
필요한 경우 스크린샷을 첨부해주세요.

## 참고자료
관련 문서나 링크를 첨부해주세요.
```

<br/>
<br/>

## PR TEMPLATE
PR명: [#이슈번호] 내용
<br/>

ex) [#14] 유저 CRUD 기능 추가
```
### PR 타입(하나 이상의 PR 타입을 선택해주세요)
- [X] 기능 추가
- [ ] 기능 삭제
- [ ] 버그 수정
- [ ] 문서 수정
- [ ] 코드 리팩토링
- [ ] 테스트 코드 추가 및 리팩토링
- [ ] 의존성, 환경 변수, 빌드 관련 코드 업데이트

### 반영 브랜치
ex) dev/feature/join

### 이슈
[#이슈 번호](이슈 링크)

### 변경 사항
ex) 로그인 시, 구글 소셜 로그인 기능을 추가했습니다. (구체적으로, 명시적으로 작성)

### 테스트 결과
ex) 베이스 브랜치에 포함되기 위한 코드는 모두 정상적으로 동작해야 합니다. 결과물에 대한 스크린샷, GIF, 혹은 라이브 데모가 가능하도록 샘플API를 첨부할 수도 있습니다.
```

<br/>

### 📌 요약

---

1. Response, Request 처리 시에 사용되는 DTO는 Record(불변객체) 타입으로 사용
2. Entity의 PK 값 생성 전략을 Identity가 아닌 UUID로 가져가는 것 고려
3. 서비스 레이어에서 각 메소드에 @Transactional 적용하기(클래스 래밸에 X)
4. 레포지토리 레이어를 정확하게 역할과 기능으로 분리(인터페이스와 구현 클래스로 구분)
5. 앤티티 클래스에 객체 생성 용도로 정적팩토리메소드 패턴 사용

# DTO Class

- DTO 클래스는 순수한 데이터 객체로써 로직을 포함하고 있지 않아야 합니다.

## Request DTO

- **Deprecated**
    - 기본 생성자를 PRIVATE로 제한하여 불완전한 객체가 생성되는 것을 방지합니다.
    - OAS3.0에서 제공하는 어노테이션들을 이용하여 필드에 대한 설명을 자세히 적어놓아야 합니다.
    - 모든 필드는 private 접근을 갖습니다.
    
    <aside>
    ⚠️ @Getter는 역직렬화 과정에 필요하기 때문에 필수적으로 있어야 합니다.
    
    </aside>
    
    ```java
    @Getter
    @NoArgsConstructor(access = AccessLevel.PRIVATE)
    public class DtoClass {
    	@Schema(
                example = "안녕하세요",
                description = "본문"
        )
        @NotBlank(message = "본문이 비어있을 수 없습니다.")
        private String body;
    }
    ```
    

### Record Class

```java
public record DtoClass(
	@Schema(
            example = "안녕하세요",
            description = "본문"
    )
    @NotBlank(message = "본문이 비어있을 수 없습니다.")
	String body
) {}
```

## Response DTO

- **Deprecated**
    - 기본 생성자를 PRIVATE로 제한하여 불완전한 객체가 생성되는 것을 방지합니다.
    - 모든 필드에 대한 생성자를 private 접근을 갖도록 하여 객체 생성은 Builder를 통해서만 가능하도록 합니다.
    
    <aside>
    💡 비즈니스 로직에서 인스턴스화 되는 Response DTO에서는 데이터 정합성을 유지해야 하기 때문에 모든 필드에 final을 붙이도록 합니다.
    
    </aside>
    
    ```java
    @Getter
    public class DtoClass {
    		private final Long id;
        private final String body;
    		@Builder
    		private DtoClass(Long id, String body) {
    			this.id = id;
    			this.body = body;
    		}
    }
    ```
    

### Record Class

```java
@Builder
public record DtoClass(
	Long id,
	String body
) {
	public static DtoClass of(Long id, String body){
		return DtoClass.builder
											.id(id)
											.body(body)
											.build();
	}
}
```

- **CommonResponseDto는 필요 시 다시 고려**
    
    ## CommonResponseDTO
    
    - **Deprecated**
        
        ```jsx
        @Getter
        public class CommonResponseDto<T> {
        		private final String msg;
            private T result;
        		public DtoClass(String msg, T result) {
        			this.msg = msg;
        			this.result = result
        	}
        }
        ```
        
    
    ### Record Class
    
    ```java
    public record CommonResponseDto<T>(
    	String msg,
    	T result
    ) {}
    ```
    
    - 모든 ResponseDTO의 결과를 CommonReponseDTO 클래스로 래핑해 클라이언트에게 제공합니다.
    
    ```jsx
    #### Controller Layer에서의 사용 예#####
    @PostMapping
        public ResponseEntity<CommonResponseDto<DtoClass>> someMethod(final Long id, final Long body) {
                return ResponseEntity.status(HttpStatus.CREATED).body(
    							new CommonResponse(
    									"정상적으로 저장되었습니다.",
    									someService.someMethod(id, body)
    									)
    								);
        }
    ```
    
    - 클라이언트가 쉽게 이해할 수 있도록 결과에 대한 설명을 함께 제공해야 합니다.
    - 반환 값이 없다면 다음과 같이 작성할 수 있습니다.
    
    ```jsx
    #### Controller Layer에서의 사용 예 #####
    @PostMapping
        public ResponseEntity<CommonResponseDto<?>> someMethod(final Long id, final Long body) {
                return ResponseEntity.status(HttpStatus.CREATED).body(
    							new CommonResponse(
    									"정상적으로 저장되었습니다.",
    									null
    									)
    								);
        }
    ```
    

# Entity Class

- Hibernate User Guide에 따르면, **Entity Class에는 인자 없는 생성자가 공개되어 있거나 보호되어있어야 한다고 합니다.** 따라서 우리는 기본 생성자를 PRO`TECTED로 제한하여 POJO Models 요구사항을 충족시킴과 동시에 불완전한 객체가 생성되는 것을 방지합니다.
- 필드나 메소드에 **Final을 사용하지 않습니다.**
- **@Setter를 사용하지 않습니다.**
- 쉽게 **의미를 파악할 수 없는 Setter 메소드를 사용하지 않습니다.**
- **private 생성자**에 builder 붙여 사용(DB id값 제외) → 외부에서 생성자 사용을 막을 수 있다.
- entity 정적 팩토리 ← 오직 생성하는 용도로(이유- 서비스 클래스에서 빌더 조립 해야함)

```java
@Entity
@Getter
@Table(name = "member")
@NoArgsConstructor(access = AccessLevel.PROTECTED)
public class Member {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String name;
		
		@Builder
		private Member(String name) {
			this.name = name;
		}
		
		// DtoClass를 이용해 member를 update한다.
		public void updateMemberByDtoClass(DtoClass dtoClass) {
        this.name = dtoClass.getName();
    }
}
```

# Controller Layer

- 생성자 주입을 통해 의존 관계를 주입해야 하고, DI된 필드는 최종적이어야 합니다.
    
    ```java
    ...
    @RequiredArgsConstructor
    ...
    public class Controller {
        private final Service service;
    ```
    
- 메소드는 ResponseEntity를 통해 올바른 Http code를 ~~CommonReponseDTO와 함께 반환해야 합니다.~~
    
    ```java
    public ResponseEntity<DtoClass> getGroup(..) {
            return ResponseEntity.status(HttpStatus.OK).body(...);
        }
    ```
    
- 메소드들의 각 인자는 최종적이어야 합니다.
    
    ```java
    public ResponseEntity<DtoClass> getGroup(final @PathVariable("id") Long id) {
            return ResponseEntity.status(HttpStatus.OK).body(...);
        }
    ```
    
- QueryString이 사용된 경우 OAS 3.0 어노테이션을 사용해 설명을 충실히 적어줍니다.
    - 따로 인터페이스를 두고, 컨트롤러가 구현해서 사용하는 방식(모든게 다 준서 책임)
    
    ```java
    @Operation(summary = "그룹 멤버 (1명) 편성", description = "저장할 member_id(멤버)와 role_id(역할)을 입력해주세요")
        @Parameters({
                @Parameter(name = "member_id", description = "멤버 ID", required = true),
                @Parameter(name = "role_id", description = "역할 ID", required = true)
        })
        @PostMapping
        public ResponseEntity<DtoClass> someMethod(final Long id, final Long body) {
                return ResponseEntity.status(HttpStatus.CREATED).body(someService.someMethod(id, body));
        }
    ```
    

# Service Layer

- 생성자 주입을 통해 의존 관계를 주입해야 하고, DI된 필드는 최종적이어야 합니다.

```java
@Service
@RequiredArgsConstructor
public class GroupService {
    private final GroupRepository groupRepository;
 }
```

- 값을 불러오는 작업만 할 때는 트랜잭션 readOnly = true 옵션을 부여합니다.

```jsx
		@Transactional(readOnly = true)
    public GroupResponseDto getGroup(Long id) {
        Group foundGroup = groupRepository.findById(id).orElseThrow(() -> new CustomNotFoundException("The requested ID was not found."));
        return GroupResponseDto.entityToDto(foundGroup);
    }
```

- findById에서 반환되는 Optional 객체를 처리하기 위해 orElseThrow, orElseGet,  ifPresentOrElse를 사용합니다.

<aside>
⚠️ ifPresentOrElse는 블록내에서 return을 반환할 수 없습니다.

</aside>

```jsx
 Group foundGroup = groupRepository.findById(id).orElseThrow(() -> new CustomNotFoundException("The requested ID was not found."));
```

- 메소드의 **반환값은 ResponseDTO이어야 합니다. CommonReponseDTO를 반환하지 않도록 합니다.**

# Repository Layer

- QueryDsl은 적극 사용을 하되, 일단 먼저 Jpql 을 활용해서 해당 방식으로 처리 하는 게 문제가 있다 판단되면 바로 적용.
1. domain - UserRepository 인터페이스 두고, ← 쿼리 dsl 은 보통 이 구조에서 많이 사용하긴 함.
    - infrastcurture 폴더 에다가 UserJpaRepository 인터페이스(Jpa 상속)
    - infrastructure 폴더 에다가 UserRepositoryImpl(여기서 queryDsl 로직 작성) 을 둬서 여기서 Jpa 인터페이스 의존성 주입 받고 사용  ← 개귀찮아 제발.
2. repository 폴더에서 UserRepository 인터페이스 + jpa 상속 + JPQL 로 메서드 작성

# 패키지 구조

- hello
    - durian
        - code
            - **common**
                - **config**
                    - **security**
                - **exception**
                    - **customs**
                - **data**
                    - **dto**
                    - **domain**
            - **User**
                - **domain**
                - **dto**
                    - request
                        - UserRequest.class
                    - response
                - **controller**
                - **repository**
                - **service**
            - **Snap**
                - **domain**
                - **dto**
                - **controller**
                - **repository**
                - **service**
            - **Social**
                - **domain**
                - **dto**
                - **controller**
                - **repository**
                - **service**
